**go 파일 컴파일 및 실행
1. 컴파일 및 빌드 : go build 파일 경로
실행 : MS Windows는 실행 파일의 경로를 적으면 되는데 현재 디렉토리 안에 있을 때는 파일명만 입력하면 되고
		Mac/Linux는 현재 디렉토리에 존재하는 경우 ./파일명 

2. 출력
fmt 패키지의 Print, Println, Printf 함수 이용

3. 작성 방법
=> 한 줄에 하나의 명령어를 입력하는 것이 기본인데 한 줄에 2개 이상의 명령어(실행문)를
	입력하는 경우에는 ;으로 구분
=> 주석은 //로 한줄 주석을 표현하고 /* */로 여러 줄의 주석을 표현
=> 블럭을 만들 때 {는 반드시 블럭을 만드는 명령어와 동일한 줄에 선언되어야 합니다.

** 구성요소
1. 프로젝트 생성
=> 워크 스페이스로 사용할 디렉토리를 설정
=> 워크 스페이스로 사용할 디렉토리를 GOPATH라는 환경 변수로 설정
=> 워크 스페이스 안에 src - 소스 파일이 저장될 디렉토리, pkg[package] - 패키지가 저장될 디렉토리, bin - 바이너리 파일이 저장될 디렉토리이라는 디렉토리를 생성

2. 소스 파일 작성
=> 모든 go 파일은 패키지(소스 코드의 모임) 안에 소속이 되어야 합니다.
=> 확장자는 go
=> 가장 상단에 자신의 패키지 이름을 작성
=> 다른 패키지를 가져와 사용할 때는 import를 해야 합니다.
=> entry point는 main 함수

3. 데이터의 분류
1) immutable과 mutable
=> immutable은 변경할 수 없는 데이터
=> mutable은 변경이 가능한 데이터 - 멀티스레드를 사용하거나 지연 적용을 이용한다면 동기화 문제를 고려

2) scala와 vector
=> scala는 1개의 데이터 - 리턴을 해줄 때는 없거나 1개의 데이터를 리턴해주어야 합니다.
=> vector는 0개 이상의 데이터 모임 - 일반적으로 반복문을 이용해서 데이터를 사용하기 때문에 
	리턴을 해줄 때 null을 리턴하면 안됩니다.

3) value와 reference
=> 메모리에 데이터 값을 저장하는 것이 Vaue Type
=> 메모리에 데이터가 있는 곳의 참조를 저장하는 것이 Reference Type

4) Variable과 Constant, 그리고 Literal
=> Literal은 사용자가 직접 인력한 데이터
10, 'a', 10.3, "Hello World" 등

=> Constant는 변경할 수 없는 데이터에 붙인 이름 - 읽기 전용을 생성하고자 할 때 사용
=> Variable은 변경할 수 있는 데이터에 붙인 이름
=> Attribute나 Property 또는 Field라고 부를 때는 대부분 변수나 상수인데 독자적으로 존재하지 못하고 다른 요소의 일부분일 때입니다.

4. 변수 선언
=> go(C++, Java, Kotlin, Swirft)는 정적 타입 언어 : 데이터의 자료형은 처음에 결정하면 변경하지 못함
=> Javascript나 Python은 동적 타입 언어 : 데이터의 자료형을 중간에 변경하는 것이 가능
=> go는 변수를 만들 때 자료형을 명시해서 결정할 수 있고 데이터를 바로 대입해서 추론할 수도 있습니다.

1) 선언과 초기화를 분리
var 변수 이름 자료형

변수 이름 = 데이터

2) 선언과 초기화를 동시에 수행
var 변수 이름 자료형 = 초기값
var 변수 이름 = 초기값      // 자료형 추론

=> 함수 내에서 만들어진는 지역 변수의 경우는 var를 생략하는 것이 가능
변수이름 := 초기값

=> 동일한 자료형의 변수는 한 줄에  선언 가능
var 변수 이름1, 변수 이름 2, ... 자료형

=> 자료형이 다른 여러 개의 변수를 한거번에 초기화 하는 것이 가능 - 알고리즘 문제 풀 때 라인수를 많이 줄여줌

5. 기본 자료형
=> bool : true 또는 false 저장
=> 부호있는 정수 : int, int8, int16, int32, int64 - int는 시스템에 따라 다름(32비트나 64비트)
=> 부호없는 정수 : uint, uint8, uint16, uint32, uint64, uintprt - uintptr은 참조를 저장하기 위한 자료형
=> 하나의 바이트 또는 ASCII 문자 : byte
=> 하나의 유니코드 문자 : rune
=> 실수 : float32, float64
=> 복소수 : complex64, complex128
=> 문자열 : string -> byte의 collection으로 간주

1) 정수 저장
=> 컴퓨터는 2진수로 저장
=> 부호 있는 정수의 경우는 첫번째 비트를 부호로 간주하고 양수는 첫번째 비트를 0으로 하고 나머지 비트에 저장하며
	음수는 양수의 2의 보수로 저장

2) 실수를 저장
=> 부호와 지수와 가수를 나누어서 저장
=> 12.7 -> 0 0.127E + 002
=> 각각의 숫자는 2진수로 변환해서 저장
=> 소수를 2진수로 변경할 때는 소수 부분에 2를 곱해서 나온 정수부분을 순서대로 기재하면 됩니다.
=> 0.6을 2진수로 변환

3) ASCII 문자(영문이나 숫자)
=> byte로 저장하고 ' ' 안에 하나의 문자를 표현

4) unicode 문자
=> rune이라는 자료형으로 저장하는데 " "안에 하나의 문자로 기재하거나 \u 코드값을 설정하면 됩니다.
=> 코드값은 16진수로 표현합니다.
=> 하나의 unicode는 3바이트입니다.

5) 기본값
=> 초기화를 하지 않은 변수에는 기본값이 설정됨
=> 숫자는 0, bool은 false, string은 "", 포인터는 nill(NULL)

6) 문자열
=> " " 안에 유니코드나 문자를 나열해서 표현
=> 여러 줄로 구성된 문자열을 만들고자 할 때는 ``(backtike, back quote)를 이용
=> 문자열의 바이트 크기는 len 함수를 이용해서 구할 수 있음
=> 글자 수는 unicode의 utf8 패키지의 RuneCountlnString 함수를 이용
=> 문자열[인덱스]를 이용해서 문자 단위로 접근 가능
=> + 연산자를 이용해서 결합 가능
=> 동일성 여부는 ==
=> 제어문자 사용 가능
\n : 줄바 꿈
\t : 탭
\r : 커서를 맨 앞으로 이동
줄 바꿈을 하고 커서를 맨 앞으로 옮길 때 \r\n으로 작성하는 경우가 있습니다.

7) 자료형 변환
(변경하고자 하는 자료형) 데이터

6. 연산자
1) = -> 대입연산자
오른쪽의 데이터가 참조하는 영역을 왼쪽의 변수에 대입

2) := -> 선언과 대입을 동시에 수행

3) ++, -- -> 증감 연산자

4) %, *, /, +, - -> 사칙 연산

5) <<, >> -> shift 연산자
=> << 는 1번 이동할 때마다 곱하기 2한 효과
=> >> 는 한번 이동할 때마다 나누기 2한 효과

6) &, |, ^, &^ : 비트 논리 연산자 - 비트 단위로 연산해서 결과를 정수로 리턴
=> &(and) : 둘 다 1일 때만 1 - 삭제를 할 때 이용
=> |(or) : 둘 다 0일 때만 0	- 데이터를 복사할 때 사용
                                        - ex) 이미지에서 2개를 합성하는 경우도 or를 사용 
=> ^(xor) : 2개가 같으면 0 다르면 1
=> &^(and not)

7) 연산 후 할당
+=, -= 등 

8) 비교 연산자
=> ==, !=, <, <=, >, >=

9) 논리 연산자
=> && : 2개의 표현식 모두 true일 때 true이고 나머지 경우는 false
앞의 표현식의 결과가 false라면 뒤의 표현식은 확인하지 않습니다.

=> || : 2개의 표현식 모두 false일 때 false이고 나머지 경우는 true
앞의 표현식의 결과가 true라면 뒤의 표현식은 확인하지 않습니다.

10) 참조 연산 : &
=> & 다음에 변수를 설정하면 변수가 가리키고 있는 참조를 의미합니다.

11) 역참조 연산 : *
=> 참조를 저장하고 있는 데이터에서 참조하고 있는 곳의 실제 값을 가져올 때 사용하는 연산자

12) 채널 수신 연산 : <-

7. Constant (상수)
=> 변하지 않는 읽기 전용의 데이터
=> var 대신에 const를 사용해서 선언
=> 반드시 초기화를 해서 생성 
=> 여러 개의 상수를 동시에 선언하는 것도 가능
=> enum(나열형 상수)
     - 여러 개의 상수를 하나의 묶음으로 만드는 것
     - iota를 이용하면 0부터 시작하는 정수를 할당하는 것이 가능
     - iota는 sequence의 기능을 가짐
     - iota를 이용한 연산 가능
package main

import "fmt"

func main() {
	/*
		const MAX int = 20
		// MAX = 20

		fmt.Println(MAX)
	*/

	const (
		MIN    = 0
		NORMAL = 5
		MAX    = 10
	)
	fmt.Println(MAX)

	const (
		ZERO = iota
		ONE
		TWO
	)
	fmt.Println(TWO)

	const (
		LBUTTON = 1 << iota
		RBUTTON = 1 << iota
		SHIFT   = 1 << iota
		CONTROL = 1 << iota
	)
	fmt.Println(CONTROL)

	const (
		SALES    = iota * 10
		ACCOUNT  = iota * 10
		RESEARCH = iota * 10
	)
	fmt.Println(RESEARCH)
}


8. 포인터
=> 메모리의 참조를 나타내기 위한 자료형
=> 포인터 변수를 선언
var 이름 * 가리키는 공간의 자료형

=> 참조를 대입
이름 = 메모리 참조(다른 포인터 변수나 &일반 변수)

=> 참조하고 있는 공간의 데이터에 접근
*이름
package main

import "fmt"

func main() {
	// 정수 메모리 공간을 가리킬 수 있는 포인터 변수 선언
	var iptr *int

	i := 10

	// 포인터 변수에 참조를 대입
	iptr = &i
	jptr := iptr
	*iptr = 40

	fmt.Println(i, *jptr)
}

9. 제어문
1) if
=> 단순 if
if 표현식 {
	수행할 내용
}

=> if ~ else
if 표현식 {
	수행할 내용
} else {
	수행할 내용
}

=> if ~ else if .. ~ else (생략 가능)
if 표현식 {
	수행할 내용
} else if 표현식 {
	수행할 내용
} else {
	수행할 내용
} 

	i := 90

	// i 값이 60이상이면 합격 아니면 불합격이라고 출력
	if i >= 60 {
		fmt.Println("합격")
	} else {
		fmt.Println("불합격")
	}

	// year에는 연도가 저장
	year := 2022

	// 윤년의 조건
	// 4의 배수이고 100의 배수는 아닌 경우
	// 400의 배수인 경우
	// 둘 중 하나의 조건을 만족하면 윤년
	// year가 윤년이면 2월은 29일이라고 출력하고 윤년이 아니면 2월은 28일이라고 출력

	if year%400 == 0 || year%4 == 0 && year%100 != 0 {
		fmt.Println("2월은 29일")
	} else {
		fmt.Println("2월은 28일")
	}

2) switch
switch 변수 {
	case 값1 :
				표현식1
	case 값2 :
				표현식2
	...
	default :
				표현식
}
=> 변수와 일치하는 case 구문의 표현식으로 수행하고 종료
      - 일치하는 값이 없으면 default 구문을 수행

=> 기본적으로 fallthrough를 하지 않음
=> 아래쪽 구문을 수행하고자 하는 경우 fallthrough를 설정해야 합니다.

=> 변수에 문자열 가능

=> 조건문도 가능
	value := "2"

	switch {
	case value == "1":
		fmt.Println("중화요리")
	case value == "2":
		fmt.Println("고기")
		fallthrough
	default:
		fmt.Println("아무거나")
	}

3) for
for 초기식; 표현식; 변화식 {
	수행할 내용
}

=> 초기식은 맨 처음 1번만 수행
=> 표현식은 true이면 내용을 수행하고 변화식으로 이동
=> 변화식의 내용을 수행하고 표현식을 확인
=> 표현식을 제외한 부분을 생략하는 것이 가능 while

4) 제어문 안에 제어문 사용 가능
=> if나 switch 안에 for를 넣을 수도 있고 for 안에 if나 switch를 삽입할 수 있음

5) break
=> for나 switch 안에 사용되서 for나 switch를 종료하는 역할

6) continue
=> for안에 사용이 되서 변화식으로 바로 이동하는 역할

7) 레이블 사용
=> 반복문이 중첩되는 경우 레이블 사용이 가능
레이블을 이용해서 특정 반복문을 중단하거나 다음으로 진행하는 것이 가능
Outer:
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if j == 2 {
				break Outer
			}
			fmt.Println(i, j)
		}
	}

8) go to
=> go to 레이블 이름을 이용하면 레이블 이름에 해당하는 곳으로 제어권이 이동됩니다.
레이블은 하단에 존재해서 넘어가는 역할을 수행합니다.
=> 구조적 프로그래밍에서는 go to 사용을 배제합니다.
Java 같은 경우는 go to는 const와 더불어 예약어이지만 사용할 수 없습니다.

10. Function(함수)
=> 코드를 하나의 이름으로 사용하기 위해서 묶어둔 것
=> 일정한 패턴을 갖는 코드가 연속적으로 존재하는 경우는 반복문을 이용해서 묶을 수 있지만 
	일정한 패턴을 갖지 않는 경우에는 반복문으로 묶을 수 없음

1) 함수 선언 방법
func 함수이름(매개변수 나열) 리턴 타입 {
	함수의 내용
	(return 데이터)
}
=> 매개변수는 없을 수 있지만 ()는 생략 안됨
=> 리턴 타입은 return을 하는 데이터가 없으면 생략 가능
=> 함수가 메모리 영역에 전역의 형태로 저장됨

2) 함수 호출
함수 이름(매개변수)
=> 전역 영역에서 동일한 이름의 함수를 찾아서 전개하고 스택을 할당받아서 함수의 내용을 수행한 후 
	함수의 내용이 종료되거나 return을 만나면 함수를 호출할 곳으로 돌아옵니다.
	- 돌아오는 것을 return 한다고 합니다.
       - return 할 때는 데이터를 가지고 리턴할 수도 있고 데이터없이 리턴할 수도 있습니다.
// 함수 선언
func display() {
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}
	fmt.Println("함수 종료")
}

func main() {
	// 일정한 패턴의 함수 호출
	// function call
	display()
	fmt.Println("동일한 코드를 사용하는 중간에 추가된 코드")
	display()
}

