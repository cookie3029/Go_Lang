** 프로그램의 메모리 구조
초창기 프로그래밍에서는 레지스터(CPU 안에 있는 메모리)만을 이용해서 프로그램을 수행
프로그래밍을 하기 위해서는 기계 구조를 전부 알아야 하는데 기계마다 구조가 달라서 프로그래밍하기가 매우 어려움

=> 레지스터와 메인 메모리로 나누어서 프로그램을 구동
초창기에는 메인 메모리를 분할하지 않음

=> 레지스터를 사용하는 부분은 프로그래밍 언어에게 맡기고 메모리만을 이용해서 프로그래밍
하나의 메모리 영역만으로 프로그래밍을 하게되면 메모리 관리를 전부 프로그래머가 해야 함

일시적으로 필요한 데이터를 저장하는 영역 - Stack이라는 자료구조 이용 
-> Stack의 생성은 함수 호출로 하고 소멸은 함수의 수행이 종료되면 자동 소멸
-> 1MB라는 크기 제한이 존재하며 1MB 이상의 데이터가 필요한 경우에는
	Heap에 데이터를 저장하고 Heap의 참조(메모리를 구별하기 위한 어떤 코드 - 주소값)를
	가리키는 형태로 사용하는데 이렇게 현재 위치가 아닌 다른 위치의 데이터 참조를 가리키기 위한
	자료형을 C계열의 언어에서는 포인터라고 부릅니다.

반 영구적으로 필요한 데이터를 저장하는 영역 - Heap이라는 자료구조 이용 
-> 프로그램이 실행되면 생성되고 프로그램이 종료되면 소멸 / 크기 제한이 없음
-> 해당 영역을 다시 개발자가 동적으로 할당하고 정리할 수 있는 영역과 한 번 할당[인스턴스, Heap]하면 
	절대로 소멸시킬 수 없는 영역으로 구분해서 사용 - static
      [함수나 클래스를 위한 코드 그리고 리터럴 형태의 상수 등으로 함수나 클래스의 이름은 외부에서 사용할 수 있도록 등록할 수 있음]
-> 이 영역에서 정리할 수 있는 영역을 정리하는 방법은 개발자가 직접 정리하는 방식[C, C++]과 누군가가 대신 정리해주는 
	방식[Garbage Collector - 가리키는 데이터가 없을 때 정리하는 방식과 reference count를 이용해서 정리하는 방식]으로 나눕니다.

자바는 Pointer라는 개념 대신에 Value Type처럼 사용하는 Premitive Type과 Non Premitive Type으로 나눕니다.
Premitive Type은 1개의 데이터 만을 저장하는 자료형이고 소문자로 자료형을 기재합니다.
배열과 인스턴스는 Non Premitive Type입니다.

1. Pointer
=> 다른 메모리 영역의 참조를 가리키기 위한 자료형
1) 선언 
var 변수명 * 가리키기 위한 메모리 영역의 자료형
=> 포인터의 자료형은 무조건 부호없는 정수
=> 크기는 파일 시스템에 따라 정해집니다.
=> 변수를 선언하게 되면 다른 영역의 참조를 저장할 준비된 것입니다.
     이러한 상태를 nil이라고 합니다. [null과 유사하지만 null은 ASCII Code로 0을 나타냅니다]

2) 메모리 할당
=> 포인터 변수가 사용할 수 있는 공간 생성
new (사용할 메모리 영역의 자료형)
=> 기본값으로 전부 초기화

3) 메모리 영역을 직접 가리키기
=> 일반 데이터의 경우는 &변수명
=> 포인터 변수의 경우는 포인터변수명

4) 사용
=> 포인터 변수는 메모리의 참조를 저장하고 있음
=> 포인터 변수를 이용해서 가리키는 영역에 저장된 데이터를 사용하고자 할 때는
		앞에 *을 붙이면 됩니다 - 역참조

5) Call By Value와 Call By reference
=> Call By Value는 함수의 매개변수가 value type으로 함수 내에서 매개변수로 받은 데이터를 변경해도
		매개변수로 넘겨준 데이터에는 아무런 영향이 없는 것
=> Call By Reference는 함수의 매개변수가 Reference Type[Pointer]으로 함수 내에서 매개변수로 받은 데이터를 
		변경하면 매개변수로 넘겨준 데이터가 변경되는 것
=> 구조적 프로그래밍에서는 Call By Reference를 이용하는 것보다는 리턴을해서 새로운 데이터를 넘겨주는 것을 권장

2. struct(구조체)
=> 여러 데이터의 집합
[필드 이름을 만들 때 주의할 점은 필드 이름이 소문자로 시작하면 다른 패키지에서는 사용할 수 없습니다.]

=> 선언
type 구조체이름 struct {
	필드 이름 자료형 형태로 필드 선언
	...
}


2) 초기화
=> 전체 필드 초기화
구조체 이름 {
	필드 이름 : 데이터,
	...
}

=> 필드 각각을 초기화하거나 사용
var 변수명 = 구조체이름{}
변수명.필드이름 = 데이터

3) 구조체 포인터
=> 전체 필드 초기화
&구조체 이름 {
	필드 이름 : 데이터,
	...
}

=> 필드 각각을 초기화하거나 사용
var 변수명 = &구조체이름{}
변수명.필드이름 = 데이터

=> 동적 메모리 할당
var 변수명 = new(구조체이름)
변수명.필드이름 = 데이터

=> 구조체에는 클래스와 다르게 생성자를 만들 수 없음
생성자와 유사한 형태로 함수를 이용해서 구조체를 생성하도록 할 수는 있습니다.
동적 메모리 할당을 받아서 리턴하는 형태로 함수를 만듭니다.

4) 메서드
=> 함수는 전역 공간에 존재해서 아무 곳에서나 이름만으로 호출할 수 있는 것을 의미하고
		메서드는 리시버를 통해서 호출하는 함수를 의미합니다.
=> 구조체 안에서 직접 함수를 만들 수는 없습니다.
=> 다른 종류의 타입과 연결해서 타입으로 만들어진 데이터를 통해서 함수를 호출할 수 있습니다.

func (리시버이름 * 구조체 이름) 함수이름(매개변수)리턴타입 {
	함수의 내용
}

메서드 호출은 구조체변수.함수이름(매개변수)의 형태입니다.
이러한 과정으로 호출하는 구조체 변수의 참조가 리시버 이름에 대입되게 됩니다.

=> 메서드를 생성할 때 리시버 다음에 *을 생략하면 구조체가 복제되서 대입됩니다.
메서드 안에서 원본 구조체의 데이터를 사용할 수 없습니다.

=> 메서드 안에서 리시버가 사용이 안될 때는 리시버 이름 대신에 _를 사용할 수 있습니다.

3. 구조체 사이의 관계
1) has a
=> 하나의 구조체 선언 안에 다른 구조체가 필드로 존재하는 경우

2) is a - 상속
=> 구조체 안에 다른 구조체 이름을 필드이름 없이 이름만 기재

4. interface
=> 메서드의 모양만 가지고 있는 개체
=> 인터페이스는 변수를 만들어도 메모리 공간을 할당받지 않습니다.

1) 생성
type 인터페이스이름 inteface {
	함수 선언
}

2) 인터페이스 적용
=> 인터페이스에 속한 함수를 메서드로 소유한 객체를 인터페이스 변수에 대입해서 사용

5. panic
=> panic을 호출하면 프로그램을 중단하고 패닉 메시지를 리턴
Assertion(단언)이라고도 합니다.

=> recover()는 패닉이 발생하면 패닉 메시지를 리턴하고 그렇지 않으면 nil을 리턴하는 함수
defer와 recover를 이용하면 패닉이 발생하더라도 프로그램을 중단시키지 않고 계속 수행하는 것이 가능합니다.
