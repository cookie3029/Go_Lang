1. Function(함수)
1) 함수의 선언 위치는 호출하는 구문보다 뒤여도 됩니다.

2) 매개변수가 여러 개인 경우 매개변수의 자료형이 동일하다면 1번만 기재해도 됩니다.

3) 가변 인자
매개변수이름 ... 자료형
=> 매개변수를 여러 개 대입해도 됩니다.
=> 매개변수를 여러 개 대입하면 하나의 데이터 묶음으로 만들어서 내부에서 사용합니다.
=> 가장 마지막 매개변수로 사용되어야 합니다.

4) 함수에서 여러 개의 데이터를 리턴하는 것이 가능

5) Named Return
=> return에서 리턴하지 않고 리턴할 때 데이터의 이름을 리턴 타입 앞에 작성해서 리턴하는 방식

6) Recursion(Recursive Call - 재귀 호출)
=> 함수가 내부에서 자기 자신을 다시 호출
=> 복잡한 문제를 단순화 시킬 수 있는 경우가 많음
=> 실행 속도가 느리고 메모리 많이 사용 : 함수의 수행이 종료되기 전에 다른 함수를 호출하기 때문에
	이전 함수의 메모리 공간이 해제되지 않은 상태에서 새로운 메모리를 할당받아야 하기 때문
=> 합계, 팩토리얼, 피보나치 수열(금융 분야의 코딩 테스트를 보실 분은 외우세요), 하노이의 탑, quick sort 등이 재귀 호출로 해결할 수 있는 대표적인 알고리즘들입니다.

7) 함수는 일급 객체 - 함수형 프로그래밍의 핵심
=> 함수는 일급 객체라는 표현은 함수도 하나의 자료형이라는 의미
=> 함수도 변수에 대입이 가능
=> 함수 안에 함수를 만들 수 있음
=> 함수를 리턴할 수 있음
=> 익명 함수를 만드는 것이 가능 - 함수의 이름을 사용하지 않고 함수를 생성
자바스크립트에서는 이 방식을 권장
Hoisting 때문입니다.

8) if문 표현식 안에서 함수 호출

9) closure
=> 함수 내부에서 만든 함수를 리턴하도록 해서 함수 외부에서 함수 내부의 데이터를 변경하는 것
=> 일반적인 언어에서 클로저는 이 역할인데 swift에서는 람다(익명 함수)를 클로저라고 합니다.
=> 클로저라는 프로그래밍 언어도 있습니다.
=> 함수 안에서 만든 변수는 지역 변수로 함수 안에서만 사용이 가능하지만 함수 
	내부에서 함수를 만들면 이 함수에서는 사용이 가능하고 이 함수를 리턴하면 외부에서 리턴된 함수를 이요애서 함수 내부의 데이터를 제어할 수 있습니다.
=> 여러 곳에서 어떤 데이터를 수정해가면서 사용하고자 하는 경우 C++이나 Go에서는 전역 변수를 만들거나 
	포인터 변수를 만들어야 합니다.
=> 전역 변수를 사용을 객체 지향에서는 권장하지 않는데 이는 전역 변수를 사용하게 되면 모든 곳에서
	접근이 가능하기 때문에 예기치 않은 수정이 발생할 수 있기 때문입니다.
=> 포인터를 이용하는 방법을 이용해서 다른 함수의 지역 변수를 핸들링할 수 있는데 객체 지향에서는 속성을 직접 접근해서
	수정하는 것을 권장하지 않습니다.
=> 이런 이유들 떼문에 여러 곳에서 수정가능한 데이터를 만들어서 사용하고자 할 대 closure를 이용합니다.

10) 지연 호출
=> 함수를 호출할 때 앞에 defer를 추가해서 호출을 하면 이 함수가 가장 나중에 호출
=> defer로 호출하는 함수는 stack에 저장해서 호출합니다.
=> 자원의 사용을 정리하는 코드나 예외를 처리하는 코드를 호출해야 할 때 주로 이용합니다.

2. Go 자료구조
1) Array(배열)
=> 동일한 자료형의 데이터들의 집합
=> 크기가 고정
=> Value Type

=> 생성
var 배열이름 [개수] 자료형

=> 값 대입
배열 이름 = [데이터 개수]자료형{데이터 나열}

=> 선언과 동시에 초기화 가능
변수명 := [크기]자료형{데이터 나열}

=> 배열의 데이터 개수는 len 함수를 이용해서 구할 수 있습니다.

=> 배열의 각 데이터를 1개씩 접근하고자 할 때는 배열 이름[인덱스] 형태로 사용하면 되는데 
	인덱스는 0부터 데이터 개수 -1까지 입니다.

=> 배열의 데이터 일부분 접근
      - 배열이름[시작위치:종료위치+1]
      - 시작 위치를 생략하면 0으로 설정
      - 종료 위치를 생략하면 len으로 구한 값

=> 배열의 전체 데이터 순회
for 인덱스, 값 := range 배열이름{
	순회하면서 수행할 내용	
}
인덱스는 0부터 데이터 개수 - 1까지의 인덱스가 순서대로 대입
값에는 배열의 데이터들이 순차적으로 하나씩 대입됩니다.
인덱스나 값을 사용하지 않을 때는 변수 이름 대신에 _를 해주면 됩니다.

=> 배열의 복제
배열을 다른 배열 변수에 대입하면 배열은 복제됩니다.
배열은 value 타입이기 때문입니다.
value 타입은 다른 변수에 대입하면 복제해서 대입됩니다.

2) slice
=> 동적으로 크기가 늘어나는 배열
=> 비열과는 다르게 레퍼런스 타입
=> 다른 slice에게 대입하면 참조 복사가 이루어집니다.
다른 slice에서 데이터를 변경하면 원본의 데이터도 변경이 됩니다.

=> 선언
var 슬라이스이름 [] 자료형
배열은 선언만 하면 만들어진 것이지만 슬라이스는 선언만 해서 만들어지는 것은 아닙니다.
다른 참조를 기억할 수 있는 공간만 생성되고 기본적으로 nil을 저장하고 있음
선언을 하고 나면 반드시 공간 할당을 하거나 초기화를 수행하거나 아니면 다른 슬라이스의 참조를 받아야 합니다.

=> 공간 할당
make([] 자료형, 개수)
make([] 자료형, 개수, 용량)

=> 데이터 접근 방법은 배열과 동일

=> 초기화해서 생성하는 것 가능
[] 자료형 {데이터 나열}
데이터를 여러 줄에 걸쳐서 작성할 때는 마지막에 ,를 붙여야 합니다.

=> slice 복제
copy 함수를 이용해서 복제할 변수와 실제 복제될 데이터를 설정하면 됩니다.

=> slice에 데이터 추가
     - append 함수를 이용해서 슬라이스에 추가할 데이터를 대입해주면 됩니다.
     - 가변 인수 함수라서 추가할 데이터는 1개여도 되고 다른 슬라이스여도 되며 
		직접 여러 개의 데이터를 입력해도 됩니다.

3) map
=> 해시 테이블이나 디셔너리라고 부르기도 하는 자료구조로 키와 값을 쌍으로 저장하는 자료구조
=> 레퍼런스 타입
=> 생성
var 맵이름 map[키자료형]값의자료형
키자료형은 특별한 경우가 아니면 문자열

=> 초기화
{key:value, key:value...}

=> 데이터 접근
맵이름[키이름]
없는 키이름을 대입하면 기본값이 리턴
실레 리턴되는 데이터는 2개인데 첫번째 데이터는 값이고 두번째 데이터는 값의 존재 여부
=를 이용해서 값을 대입하면 없는 키의 경우는 추가되고 존재하는 키는 수정됨

=> make(map[키의 자료형]값의 자료형)으로 메모리 할당 가능

3. Pointer
=> 메모리의 참조를 저장하기 위한 자료형

1) 선언
var 변수 이름 *데이터의자료형
기본적으로 nil 값을 저장

2) 메모리 할당