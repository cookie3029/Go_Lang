**go
1. GO
=> 2012년 3월에 정식 발표된 구글에서 만든 프로그래밍 언어 - C++의 대안으로 생성
=> 이름은 Go인데 다른 단어와의 중복 문제 때문에 GoLang으로 검색하거나 발음합니다.
=> Go 언어인 사용자들을 Gopher라고 하고 연례 행사인 GopherCon이 세계 각국에서 열리고 있음
=> 컴파일러 언어이지만 컴파일 속도가 매우 빨라서 인터프리터 언어처럼 사용하는 것이 가능
=> Go는 Go Runtime이라는 비동기 메커니즘을 제공
      - 비동기 메커니즘은 Erlang에서 영향을 받은 것으로 각각의 Go Routine은 병렬로 동작하며
	  	메시지 채널을 통해 데이터를 주고 받음
      - Go Routine을 사용하면 이벤트 처리, 병렬 프로그래밍이 간단해 짐
      - Go Routine은 멀티 스레드 메커니즘이지만 자체 스케줄러에 의해 관리되는 경량 스레드라서 여러 개를 동시에 작성해도 성능에 문제가 생기지 않음

=> Go는 단순함과 실용성을 지향하는 언어로 Keyword가 25개 정도밖에 되지 않아서 문법이 간결하고 입문이 쉬운편
=> 메모리 관리가 쉬움
=> 기본 라이브러리가 많이 제공됨
=> 가상화 컨테이너인 Docker 개발에 사용
=> 클라우드 환경을 위한 오픈 소스 프로젝트들의 상당수가 Go로 작성됨 - Kubernetes
=> 단점
      - 바이트 코드를 생성하는 언어가 아니기 때문에 플랫폼에 종속 : Windows에서 컴파일을 하게 되면 컴파일한 코드는 Mac이나 Windows에서는 실행이 안됨
      - C++보다는 고성능 연산에 취약해서 C++ 대용이 될 수 없고 서버 애플리케이션 개발에 주로 이용
      - 최근의 프로그래밍 언어와 다르게 Null Pointer 문제나 안전하지 않은 타입 캐스팅 유발에 대한 문제에 대해서는 전혀 손을 대지 않음
      - 대다수 언어가 지원하는 일반화 프로그래밍(제너릭) 2022년도 버전에서 지원

1) 설치
=> https://go.dev/dl/ 에서 자신의 운영체제에 맞는 버전을 다운로드 받아서 설치

2) 개발 환경
=> 온라인에서 로직 테스트 : https://go.dev/play/

=> 로컬에서 개발
      - 워크 스페이스로 사용할 디렉토리를 생성
      - 워크 스페이스로 사용할 디렉토리 안에 3개의 디렉토리 생성(src, pkg, bin)
         src : 소스 코드가 위치
         pkg : 컴파일 된 패키지 파일이 저장되는 디렉토리
         bin :  실행을 위한 바이너리 코드가 저장되는 디렉토리

      - 워크 스페이스로 사용할 디렉토리 경로를 GOPATH라는 환경 변수로 등록
         Linux나 Mac의 경우는 터미널에서 export GOPATH=워크스페이스경로
	  Windows는 직접 등록

      - 컴파일 및 빌드
         go build 소스 파일 경로 또는 소스 파일 경로 생략

      - 실행
         Linux나 Mac은 ./main 함수를 가진 소스 이름
         Windows는 main 함수를 가진 소스 이름

2. 구성 요소
1) 콘솔 출력
import 'fmt'

fmt.println(데이터) : 데이터를 출력하고 줄 바꿈 
fmt.print(데이터) : 데이터만 출력
fmt.printf("서식 나열", 데이터 나열) : 데이터를 서식에 맞추어서 출력

=> 서식은 % 다음에 영문자 한 개로 구성
%d, %i : 정수
%f 	: 실수
%b 	: boolean
%s 	: 문자열

2) go 프로그래밍에서의 { }
=> { 는 반드시 자신의 제어 명령어와 같은 줄에서 작성되어야 함

3) ; => javascript나 phthon, kotlin, swft가 모두 동일
=> 명령문의 끝을 나타내는 기호가 없음
=> 하나의 줄에 여러 개의 명령문이 있을 때 각 명령문을 구분하는 용도로 사용

4) 주석
=> 한 줄 주석 : // 주석
=> 여러 줄 주석 : /* 여러 줄 주석 */

3. Package
=> go 프로그램은 1개 이상의 패키지로 구성
=> 1개 이상의 go 소스 파일을 포함하는 디렉토리이고 모든 go 파일은 패키지에 속해야 함
=> 패키지 이름은 go 파일의 최상단에 작성
     - package 자신이 속한 패키지 이름
=> 패키지 이름은 소문자로 만들고 패키지의 디렉토리 이름은 패키지와 동일하게 만드는 것이 관레

1) 패키지 import
=> 다른 패키지를 사용할 때는 import를 해주어야 합니다.

=> 하나의 패키지를 import
      - import "패키지 이름"

=> 패키지 안에 속한 패키지를 import
      - import "외부 패키지 이름/내부 패키지 이름"

=> 여러 개의 패키지를 import
      - import {
		패키지 이름	
		패키지 이름	
		패키지 이름	
        }

=> go 프로그래밍에서는 사용하지 않는 패키지를 import 하는 것은 에러
     - 사용하지 않는 패키지를 import 하고자 하는 경우는 패키지 이름 앞에 _를 붙이면 됨

=> 패키지를 가져올 때 현재 모듈에 있는 형태로 가져오고자 할 때는 import 다음에 .을 추가해주면 됩니다.
package main

import . "fmt"

func main() {
	Println("Hello Go")

	// fmt.Println("Hello Go")
	// fmt.Println("Hello")
	// fmt.Println("Go")
	// fmt.Println()

	// fmt.Print("Hello")
	// fmt.Print("Go\n\n")

	// fmt.Printf("%s\n\n", "Hello")

	// fmt.Printf("i:%d\n", 20)
	// fmt.Printf("i:%f\n", 20.65422)

	// // 소수 3째 자리까지만 출력 - 4째 자리에서 반올림
	// fmt.Printf("i:%.3f\n", 20.65422)

	// // 각 정수를 5자리씩 자리를 확보한 후 출력
	// fmt.Printf("i:%5d%5d\n", 20, 10)

	// // 앞의 빈자리에 0을 추가
	// fmt.Printf("i:%05d%05d\n", 20, 10)

	// i := 10

	// if i > 5 {
	// 	fmt.Println("5 이상의 숫자")
	// } else {
	// 	fmt.Println("5 미만의 숫자")
	// }

	// fmt.Println("하나의 출력 명령어");
	// fmt.Println("하나의 출력 명령어")
	// fmt.Println("하나의 출력 명령어")

	// // 한 줄에 2개의 명령문이 존재하는 경우는 각 명령문을 구분하기 위해서 ;을 사용
	// fmt.Println("하나의 출력 명령어"); fmt.Println("하나의 출력 명령어")
}

=> 패키지 이름에 새로운 이름을 부여해서 가져오기 - 기존 패키지 이름 사용 못함
      - import 별명 "패키지 이름"

4. 변수 및 자료형
1) 변수 (Variable)
=> 데이터가 저장되는 곳에 붙이는 이름
데이터를 재사용할 때 이름을 이용해서 편리하게 사용하고 유지 보수를 편리하게 하기 위해서 이름을 생성

=> 선언
var 변수이름 자료형

=> 데이터에 이름을 사용
변수이름 = 데이터

변수 이름은 먼저 선언되어야 하고 변수를 만들 때 사용한 자료형과 데이터의 자료형에 대해 호환성이 있어야 합니다.
go는 정적 타이핑 언어이므로 자료형을 명시해야 하고 이 자료형과 다른 자료형의 데이터에는 변수 이름을 사용할 수 없음

=> 변수의 선언과 동시에 초기화 : 자료형을 생략하는 것이 가능한데 초기값을 가지고 자료형을 유추하기 때문
var 변수이름 자료형 = 초기값
var 변수이름 = 초기값

=> 동일한 자료형의 여러 개의 변수 선언 가능
var 변수1, 변수2.. 자료형

=> 여러 개의 변수를 한꺼번에 선언과 초기화가 가능
자료형이 생략하는 것이 가능하기 때문에 서로 다른 자료형도 선언과 동시에 초기화가 가능
package main

import "fmt"

func main() {
	var x int = 20
	fmt.Println(x)

	// 선언과 동시에 초기화 하는 경우는 자료형 생략이 가능
	var y = 30
	fmt.Println(y)

	// 서로 다른 자료형의 데이터를 동시에 초기화
	var i, f = 10, 20.7
	fmt.Printf("x=%d y=%f\n", i, f)
}

=> 함수 안에서는 var와 자료형 대신에 := 이용해서 선언과 동시에 초기화를 수행할 수 있습니다.
자료형은 생략을 하기 때문에 추론
var x int = 10
x := 10

2) 기본 자료형
=> bool : boolean으로 true 또는 false를 저장

=> int, int8, int16, int32, int64 : 부호 있는 정수를 저장, 각 숫자는 비트 수이며 int는 시스템에 따라 다른데 32비트나 64비트
     - 최근의 시스템에서는 대부분 64비트